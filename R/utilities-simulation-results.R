#' Returns the simulated values for the selected outputs (e.g molecules or parameters)
#'
#' The function receives an object of simulation results generated by running the simulation
#' and returns time-values profiles for the chosen quantities. Results of a simulation
#' of a single individual is treated as a population simulation with only one individual.
#'
#' @param simulationResults Object of type \code{SimulationResults} produced by calling \code{runSimulation}
#' on a \code{Simulation} object.
#'
#' @param quantitiesOrPaths Quantity instances (element or vector) typically retrieved using
#' \code{getAllQuantitiesMatching} or quantity path (element or vector of strings) for which the results are to be returned. (optional)
#' When providing the paths, only absolute full paths are supported (i.e., no matching with '*' possible).
#' If quantitiesOrPaths is \code{NULL} (default value), returns the results for all output defined in the results.
#'
#' @param individualIds \code{numeric} IDs of individiuals for which the results should be extracted.
#' By default, all individuals from the results are considered. If the individual with the provided ID is not found, the ID is ignored
#'
#' @param population population used to calculate the simulationResults (optional). This is used only to add the population covariates to the resulting data table.
#'
#' @param stopIfNotFound Boolean. If TRUE and no result exist for the given path, an error is thrown. Default is \code{TRUE}
#' @param stopIfNotFound If \code{TRUE} (default) an error is thrown if no results exist for any `path`
#' If \code{FALSE}, a list of \code{NA} values is returned for the repsecitve path.
#' @export
getOutputValues <- function(simulationResults,
                            quantitiesOrPaths = NULL,
                            population = NULL,
                            individualIds = NULL,
                            stopIfNotFound = TRUE) {
  validateIsOfType(simulationResults, SimulationResults)
  validateIsOfType(population, Population, nullAllowed = TRUE)
  validateIsNumeric(individualIds, nullAllowed = TRUE)
  validateIsOfType(quantitiesOrPaths, c(Quantity, "character"), nullAllowed = TRUE)

  quantitiesOrPaths <- quantitiesOrPaths %||% simulationResults$allQuantityPaths
  quantitiesOrPaths <- c(quantitiesOrPaths)

  if (length(quantitiesOrPaths) == 0) {
    return(list(data = NULL, metaData = NULL))
  }

  # If quantities are passed, get their paths.
  if (isOfType(quantitiesOrPaths, Quantity)) {
    quantities <- uniqueEntities(quantitiesOrPaths)
    paths <- unlist(lapply(quantities, function(x) x$path), use.names = FALSE)
  } else {
    paths <- unique(quantitiesOrPaths)
    quantities <- lapply(paths, function(path) {
      getQuantity(path, simulationResults$simulation, stopIfNotFound)
    })
  }
  names(quantities) <- paths

  # If no specific individual ids are passed, iterate through all individuals
  individualIds <- ifNotNull(individualIds, unique(individualIds), simulationResults$allIndividualIds)

  # All time values are equal
  timeValues <- simulationResults$timeValues
  valueLength <- length(timeValues)
  covariateNames <- ifNotNull(population, population$allCovariateNames, NULL)

  individualPropertiesCache <- vector("list", length(individualIds))
  # create a cache of all individual values that are constant independent from the path
  for (individualIndex in seq_along(individualIds)) {
    individualId <- individualIds[individualIndex]
    individualProperties <- list(IndividualId = rep(individualId, valueLength))

    for (covariateName in covariateNames) {
      covariateValue <- population$getCovariateValue(covariateName, individualId)
      individualProperties[[covariateName]] <- rep(covariateValue, valueLength)
    }

    individualProperties$Time <- timeValues
    # Save one data frame with all individual properties per individual so that we can easily concatenate them
    individualPropertiesCache[[individualIndex]] <- individualProperties
  }

  # Cache of all individual properties over all individual that will be duplicated in all resulting data.frame
  allIndividualProperties <- do.call(rbind.data.frame, c(individualPropertiesCache, stringsAsFactors = FALSE))


  values <- lapply(paths, function(path) {
    simulationResults$getValuesByPath(path, individualIds, stopIfNotFound)
  })
  names(values) <- paths

  metaData <- lapply(paths, function(path) {
    quantity <- quantities[[path]]
    list(unit = quantity$unit, dimension = quantity$dimension)
  })
  names(metaData) <- paths
  metaData[["Time"]] <- list(unit = "min", dimension = "Time")

  data <- data.frame(allIndividualProperties, values, stringsAsFactors = FALSE, check.names = FALSE)
  return(list(data = data, metaData = metaData))
}

#' Saves the simulation results to csv file
#'
#' @param results Results to export (typically calculated using \code{runSimulation} or imported from file)
#' @param filePath Full path where the results will be saved.
#'
#' @examples
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#'
#' # Load the simulation
#' sim <- loadSimulation(simPath)
#'
#' # Add some outputs to the simulation
#' addOutputs("Organism|**|*", sim)
#'
#' # Run the simulation
#' results <- runSimulation(sim)
#'
#' # Export the results to csv file
#' exportResultsToCSV(results, tempfile())
#' @export
exportResultsToCSV <- function(results, filePath) {
  validateIsOfType(results, SimulationResults)
  validateIsString(filePath)
  filePath <- expandPath(filePath)
  simulationResultsTask <- getNetTask("SimulationResultsTask")
  rClr::clrCall(simulationResultsTask, "ExportResultsToCSV", results$ref, results$simulation$ref, filePath)
  invisible()
}


#' Imports the simulation results from one or more csv files
#'
#' @param simulation Instance of a simulation used to calculate the results
#' @param filePaths Full path of result files to import. Typically only one
#' file is provided but a list of files is sometimes available when the simulation
#' was parallelized and computed on different machines
#'
#' @examples
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#' resultPath <- system.file("extdata", "res.csv", package = "ospsuite")
#'
#' # Load the simulation
#' sim <- loadSimulation(simPath)
#'
#' # Run the simulation
#' results <- importResultsFromCSV(sim, resultPath)
#' @export
importResultsFromCSV <- function(simulation, filePaths) {
  validateIsOfType(simulation, Simulation)
  validateIsString(filePaths)
  simulationResultsTask <- getNetTask("SimulationResultsTask")
  filePaths <- unlist(lapply(filePaths, function(filePath) expandPath(filePath)), use.names = FALSE)

  results <- rClr::clrCall(simulationResultsTask, "ImportResultsFromCSV", simulation$ref, filePaths)
  SimulationResults$new(results, simulation)
}
