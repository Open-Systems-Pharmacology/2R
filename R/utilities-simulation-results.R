#' Get simulated values of selected outputs (e.g molecules or parameters)
#'
#' Return values for given entities generated in a population simulation.
#'
#' The function receives an object of simulation results generated by running the simulation
#' and returns time-values profiles for the chosen quantities. Results of a simulation
#' of a single individual is treated as a population simulation with only one individual.
#'
#' @param simulationResults Object of type \code{SimulationResults} produced by calling \code{runSimulation}
#' on a \code{Simulation} object.
#' @param quantitiesOrPaths Quantity instances (element or vector) (typically retrieved using
#' \code{getAllQuantitiesMatching}) or quantity path (element or vector of strings) for which the results are to be returned.
#' When providing the paths, only absolute full paths are supported (i.e., no matching with '*' possible)
#' @param individualIds \code{numeric} IDs of individiuals for which the results should be extracted.
#' By default, all individuals from the results are considered. If the individual with the provided ID is not found, the ID is ignored
#'
#' @return A list of results, each entry having the name of a quantity path and consisting of the element \code{x} being the time values (in minutes)
#' and the element \code{y} a \code{NxM} matrix of simulated values, with \code{N} the number of entries (equals the number of output time steps)
#' and \code{M} the number of individuals. If no individual contains the results for a given path, the value of the element is \code{NULL}
#'
#' @export
#'
#' @examples
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#' sim <- loadSimulation(simPath)
#' simResults <- runSimulation(sim)
#'
#' paths <- "Organism|Volume"
#'
#' resultsValues <- getOutputValues(simResults, paths)
#' plot(resultsValues[[paths]])
getOutputValues <- function(simulationResults, quantitiesOrPaths, individualIds = NULL) {
  validateIsOfType(simulationResults, SimulationResults)
  quantitiesOrPaths <- c(quantitiesOrPaths)
  validateIsOfType(quantitiesOrPaths, c(Quantity, "character"))
  validateIsNumeric(individualIds, nullAllowed = TRUE)

  # If quantities are passed, get their paths.
  paths <- quantitiesOrPaths
  if (isOfType(quantitiesOrPaths, Quantity)) {
    paths <- unlist(lapply(quantitiesOrPaths, function(x) x$consolidatePath))
  }
  paths <- unique(paths)

  # If no specific individual ids are passed, iterate through all individuals
  if (is.null(individualIds)) {
    individualIds <- simulationResults$allIndividualIds
  }
  else {
    individualIds <- unique(individualIds)
  }

  # Pre-alloate a list with the number of entries equal to the number of paths
  output <- vector("list", length(paths))
  names(output) <- paths
  # All time values are equal
  timeValues <- simulationResults$timeValues

  for (path in paths) {
    # Pre-allocate the output matrix. The number of rows equals the number of simulated time points.
    # The number of columns is the number of possible individuals.
    outputValues <- matrix(nrow = length(timeValues), ncol = max(length(individualIds), simulationResults$count), dimnames = NULL)

    for (individualIndex in seq_along(individualIds)) {
      individualId <- individualIds[individualIndex]
      vals <- simulationResults$getValuesForIndividual(path = path, individualId = individualId)
      if (is.null(vals)) {
        next
      }
      outputValues[, individualIndex] <- vals
    }
    # Remove all NAs, i.e. columns for individuals that are not present in the
    # results. Solution from https://github.com/sfirke/janitor
    mask_keep <- colSums(!is.na(outputValues)) > 0
    outputValues <- outputValues[, mask_keep, drop = FALSE]

    # Only fill the entry if at least one individual has the output
    if (!(length(outputValues) == 0)) {
      output[[path]][["x"]] <- timeValues
      output[[path]][["y"]] <- outputValues
    }
  }
  return(output)
}

#' Export values that can be plugged directly into the TLF lib (TODO)
#'
#' @export
getOutputValuesTLF <- function(simulationResults, population, quantitiesOrPaths = NULL, individualIds = NULL) {
  validateIsOfType(simulationResults, SimulationResults)
  validateIsOfType(population, Population)
  validateIsNumeric(individualIds, nullAllowed = TRUE)
  validateIsOfType(quantitiesOrPaths, c(Quantity, "character"), nullAllowed = TRUE)

  quantitiesOrPaths <- quantitiesOrPaths %||% simulationResults$allQuantityPaths
  quantitiesOrPaths <- c(quantitiesOrPaths)

  # If quantities are passed, get their paths.
  paths <- quantitiesOrPaths
  if (isOfType(paths, Quantity)) {
    paths <- unlist(lapply(paths, function(x) x$consolidatePath))
  }
  paths <- unique(paths)

  result <- list()

  if (length(paths) == 0) {
    return(result)
  }

  # If no specific individual ids are passed, iterate through all individuals
  individualIds <- ifNotNull(individualIds, unique(individualIds), simulationResults$allIndividualIds)

  # All time values are equal
  timeValues <- simulationResults$timeValues
  valueLength <- length(timeValues)
  covariateNames <- population$allCovariateNames

  metaData <- list(
    Time = list(unit = "min", dimension = "Time")
  )

  individualPropertiesCache  <- vector("list", length(individualIds))
  # create a cache of all indivdual values that are constant independent from the path
  for (individualIndex in seq_along(individualIds)) {
    individualId <- individualIds[individualIndex]
    covariates <- population$covariatesAt(individualId)
    individualProperties <- list(IndividualId = rep(individualId, valueLength), Time = timeValues)

    for (covariateName in covariateNames) {
      individualProperties[[covariateName]] <- rep(covariates$valueFor(covariateName), valueLength)
    }

    individualPropertiesCache[[individualIndex]] <-individualProperties;
  }

  for (path in paths) {
    quantity <- getQuantity(path, simulationResults$simulation)
    resultsForPath <- vector("list", length(individualIds))
    metaData$Value <- list(unit = quantity$unit, dimension = quantity$dimension)
    pathColumn <- rep(path, valueLength)

    for (individualIndex in seq_along(individualIds)) {
      individualId <- individualIds[individualIndex]
      individualProperties <- individualPropertiesCache[[individualIndex]]
      values <- simulationResults$getValuesForIndividual(path, individualId)
      resultsForPath[[individualIndex]] <- data.frame(individualProperties, Path = pathColumn, Value = values)
    }

    data <- do.call(rbind, resultsForPath)
    result[[path]] <- list(data = data, metaData = metaData)
  }

  return(result)
}

#' Saves the simulation results to csv file
#'
#' @param results Results to export (typically calculated using \code{runSimulation} or imported from file)
#' @param filePath Full path where the results will be saved.
#'
#' @examples
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#'
#' # Load the simulation
#' sim <- loadSimulation(simPath)
#'
#' # Add some outputs to the simulation
#' addOutputs("Organism|**|*", sim)
#'
#' # Run the simulation
#' results <- runSimulation(sim)
#'
#' # Export the results to csv file
#' exportResultsToCSV(results, tempfile())
#' @export
exportResultsToCSV <- function(results, filePath) {
  validateIsOfType(results, SimulationResults)
  validateIsString(filePath)
  simulationResultsTask <- getNetTask("SimulationResultsTask")
  rClr::clrCall(simulationResultsTask, "ExportResultsToCSV", results$ref, results$simulation$ref, filePath)
  invisible()
}


#' Imports the simulation results from one or more csv files
#'
#' @param simulation Instance of a simulation used to calculate the results
#' @param filePaths Full path of result files to import. Typically only one
#' file is provided but a list of files is sometimes available when the simulation
#' was parallelized and computed on different machines
#'
#' @examples
#' simPath <- system.file("extdata", "simple.pkml", package = "ospsuite")
#' resultPath <- system.file("extdata", "res.csv", package = "ospsuite")
#'
#' # Load the simulation
#' sim <- loadSimulation(simPath)
#'
#' # Run the simulation
#' results <- importResultsFromCSV(sim, resultPath)
#' @export
importResultsFromCSV <- function(simulation, filePaths) {
  validateIsOfType(simulation, Simulation)
  validateIsString(filePaths)
  simulationResultsTask <- getNetTask("SimulationResultsTask")
  results <- rClr::clrCall(simulationResultsTask, "ImportResultsFromCSV", simulation$ref, filePaths)
  SimulationResults$new(results, simulation)
}
